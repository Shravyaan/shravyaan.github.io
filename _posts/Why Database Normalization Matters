layout: default
title: 'Mastering the Data: Why Database Normalization Matters'

Mastering the Data: Why Database Normalization Matters

This week, I moved beyond just building databases to understanding the "science" behind them. While working on my Aviation project, I realized that how we structure data is the difference between a system that scales and a system that suffers from data corruption.

The Problem: Data Messiness

I started with a simple "Flight Log" table. It had everything: flight IDs, pilot names, airport cities, and aircraft models all in one place. It worked fine for five rows, but I quickly encountered Anomalies. If a pilot changed their license, I had to update it in fifty different rows. If I deleted a flight, I accidentally deleted the pilot’s entire profile. This is why we normalize.

Breaking Down the Stages (1NF, 2NF, 3NF)

To fix my flight database, I applied the three "Golden Rules" of normalization. Here is how I broke it down:

1NF (First Normal Form) - Atomic Values:
In my initial design, I had a column for "Pilots" that listed two people in one cell. This made it impossible to run a query to find a specific pilot. 1NF taught me that every cell must be indivisible. I moved to a structure where every assignment is its own unique record.

2NF (Second Normal Form) - The Whole Key:
This was my first "aha!" moment. I was using a composite key (Flight ID + Pilot ID). I had a column for "Pilot License Type" in that same table. But a pilot's license doesn't depend on the flight they are flying; it only depends on the Pilot ID. 2NF taught me to move that data to a separate Pilots table so it only exists in one place.

3NF (Third Normal Form) - Nothing But the Key:
This is the final polish. In my Flights table, I had Airport_Code and Airport_City. But the city depends on the airport, not the flight. This is a "transitive dependency." I moved all airport details into an Airports table, ensuring that the Flights table only cares about the flight itself.

The "Codd" Mnemonic

The best way to remember this is a quote I found: "The data depends on the key (1NF), the whole key (2NF), and nothing but the key (3NF), so help me Codd." (Named after E.F. Codd, the father of relational databases).

Why It Matters for DevOps and SDE

As I prepare for SDE and DevOps roles, I'm learning that normalization isn't just about "neatness." It’s about Infrastructure Efficiency. Normalized databases are faster to index, require less storage, and—most importantly—prevent the logic errors that cause systems to crash during high-traffic events.

What's Next?

With a clean database structure now in place, I’m moving back into the cloud. My next goal is to explore how these relational structures interact with AWS DynamoDB (NoSQL) to see how scaling changes when we move away from traditional SQL.

You can see my updated database schema and normalization README here:
https://github.com/shravyaan
